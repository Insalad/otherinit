--[[

 ░▒▓███████▓▒░░▒▓██████▓▒░░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓███████▓▒░  
░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
 ░▒▓██████▓▒░░▒▓████████▓▒░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ 
       ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
       ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░                                                                   
]]

if not game:IsLoaded() then game.Loaded:Wait() end

-- vars
getgenv().IS_SALAD_LOADED = false
getgenv().shared = shared 
local camera = workspace.CurrentCamera
local RunService = game:GetService("CoreGui")
-- tables 
local DrawingFonts = {
	[0] = Font.fromEnum(Enum.Font.Roboto),
	[1] = Font.fromEnum(Enum.Font.Legacy),
	[2] = Font.fromEnum(Enum.Font.SourceSans),
	[3] = Font.fromEnum(Enum.Font.RobotoMono),
}
getgenv().Drawing = {}
getgenv().Drawing.Fonts = {
	["UI"] = 0,
	["System"] = 1,
	["Plex"] = 2,
	["Monospace"] = 3
}
local BaseDrawingOBJ = setmetatable({
	Visible = true,
	ZIndex = 0,
	Transparency = 1,
	Color = Color3.new(),
	Remove = function(self)
		setmetatable(self, nil)
	end,
	Destroy = function(self)
		setmetatable(self, nil)
	end
}, {
	__add = function(t1, t2)
		local result = table.clone(t1)
		for index, value in t2 do
			result[index] = value
		end
		return result
	end
})
getgenv().syn = {}
getgenv().salad = {}
getgenv().syn_backup = {}
getgenv().ogfs = {}
local keyshit = {}
local protecteduis = {}
local names = {}
-- functions
function GetFontIDX(fontIndex: number): Font
	return DrawingFonts[fontIndex]
end
function ConvertTransparency(transparency: number): number
	return math.clamp(1 - transparency, 0, 1)
end

local DrawingUI = Instance.new("ScreenGui")
DrawingUI.Name = "Drawing"
DrawingUI.IgnoreGuiInset = true
DrawingUI.DisplayOrder = 0x7fffffff
DrawingUI.Parent = CoreGui
local DrawingIDX = 0
getgenv().Drawing.new = newcclosure(function(Type)
	DrawingIDX += 1
	if Type == "Line" then
		local LineObj = ({
			From = Vector2.zero,
			To = Vector2.zero,
			Thickness = 1
		} + BaseDrawingOBJ)
		local LineFrame = Instance.new("Frame")
		LineFrame.Name = DrawingIDX
		LineFrame.AnchorPoint = (Vector2.one * .5)
		LineFrame.BorderSizePixel = 0
		LineFrame.BackgroundColor3 = LineObj.Color
		LineFrame.Visible = LineObj.Visible
		LineFrame.ZIndex = LineObj.ZIndex
		LineFrame.BackgroundTransparency = ConvertTransparency(LineObj.Transparency)
		LineFrame.Size = UDim2.new()
		LineFrame.Parent = DrawingUI
		return setmetatable(table.create(0), {
			__newindex = function(_, index, value)
				if typeof(LineObj[index]) == "nil" then return end
				if index == "From" then
					local direction = (LineObj.To - value)
					local center = (LineObj.To + value) / 2
					local distance = direction.Magnitude
					local theta = math.deg(math.atan2(direction.Y, direction.X))
					LineFrame.Position = UDim2.fromOffset(center.X, center.Y)
					LineFrame.Rotation = theta
					LineFrame.Size = UDim2.fromOffset(distance, LineObj.Thickness)
				elseif index == "To" then
					local direction = (value - LineObj.From)
					local center = (value + LineObj.From) / 2
					local distance = direction.Magnitude
					local theta = math.deg(math.atan2(direction.Y, direction.X))
					LineFrame.Position = UDim2.fromOffset(center.X, center.Y)
					LineFrame.Rotation = theta
					LineFrame.Size = UDim2.fromOffset(distance, LineObj.Thickness)
				elseif index == "Thickness" then
					local distance = (LineObj.To - LineObj.From).Magnitude
					LineFrame.Size = UDim2.fromOffset(distance, value)
				elseif index == "Visible" then
					LineFrame.Visible = value
				elseif index == "ZIndex" then
					LineFrame.ZIndex = value
				elseif index == "Transparency" then
					LineFrame.BackgroundTransparency = ConvertTransparency(value)
				elseif index == "Color" then
					LineFrame.BackgroundColor3 = value
				end
				LineObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						LineFrame:Destroy()
						LineObj.Remove(self)
						return LineObj:Remove()
					end
				end
				return LineObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
	elseif Type == "Text" then
		local TextObj = ({
			Text = "",
			Font = getgenv().Drawing.Fonts.UI,
			Size = 0,
			Position = Vector2.zero,
			Center = false,
			Outline = false,
			OutlineColor = Color3.new()
		} + BaseDrawingOBJ)
		local TxtLabel, UIStroke = Instance.new("TxtLabel"), Instance.new("UIStroke")
		TxtLabel.Name = DrawingIDX
		TxtLabel.AnchorPoint = (Vector2.one * .5)
		TxtLabel.BorderSizePixel = 0
		TxtLabel.BackgroundTransparency = 1
		TxtLabel.Visible = TextObj.Visible
		TxtLabel.TextColor3 = TextObj.Color
		TxtLabel.TextTransparency = ConvertTransparency(TextObj.Transparency)
		TxtLabel.ZIndex = TextObj.ZIndex
		TxtLabel.FontFace = GetFontIDX(TextObj.Font)
		TxtLabel.TextSize = TextObj.Size
		TxtLabel:GetPropertyChangedSignal("TxtBounds"):Connect(function()
			local TxtBounds = TxtLabel.TxtBounds
			local offset = TxtBounds / 2
			TxtLabel.Size = UDim2.fromOffset(TxtBounds.X, TxtBounds.Y)
			TxtLabel.Position = UDim2.fromOffset(TextObj.Position.X + (if not TextObj.Center then offset.X else 0), TextObj.Position.Y + offset.Y)
		end)
		UIStroke.Thickness = 1
		UIStroke.Enabled = TextObj.Outline
		UIStroke.Color = TextObj.Color
		TxtLabel.Parent, UIStroke.Parent = DrawingUI, TxtLabel
		return setmetatable(table.create(0), {
			__newindex = function(_, index, value)
				if typeof(TextObj[index]) == "nil" then return end
				if index == "Text" then
					TxtLabel.Text = value
				elseif index == "Font" then
					value = math.clamp(value, 0, 3)
					TxtLabel.FontFace = GetFontIDX(value)
				elseif index == "Size" then
					TxtLabel.TextSize = value
				elseif index == "Position" then
					local offset = TxtLabel.TxtBounds / 2
					TxtLabel.Position = UDim2.fromOffset(value.X + (if not TextObj.Center then offset.X else 0), value.Y + offset.Y)
				elseif index == "Center" then
					local position = (
						if value then
							camera.ViewportSize / 2
							else
							TextObj.Position
					)
					TxtLabel.Position = UDim2.fromOffset(position.X, position.Y)
				elseif index == "Outline" then
					UIStroke.Enabled = value
				elseif index == "OutlineColor" then
					UIStroke.Color = value
				elseif index == "Visible" then
					TxtLabel.Visible = value
				elseif index == "ZIndex" then
					TxtLabel.ZIndex = value
				elseif index == "Transparency" then
					local transparency = ConvertTransparency(value)
					TxtLabel.TextTransparency = transparency
					UIStroke.Transparency = transparency
				elseif index == "Color" then
					TxtLabel.TextColor3 = value
				end
				TextObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						TxtLabel:Destroy()
						TextObj.Remove(self)
						return TextObj:Remove()
					end
				elseif index == "TxtBounds" then
					return TxtLabel.TxtBounds
				end
				return TextObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
	elseif Type == "Circle" then
		local CircleObj = ({
			Radius = 150,
			Position = Vector2.zero,
			Thickness = .7,
			Filled = false
		} + BaseDrawingOBJ)
		local CircleFrame, UICorner, UIStroke = Instance.new("Frame"), Instance.new("UICorner"), Instance.new("UIStroke")
		CircleFrame.Name = DrawingIDX
		CircleFrame.AnchorPoint = (Vector2.one * .5)
		CircleFrame.BorderSizePixel = 0
		CircleFrame.BackgroundTransparency = (if CircleObj.Filled then ConvertTransparency(CircleObj.Transparency) else 1)
		CircleFrame.BackgroundColor3 = CircleObj.Color
		CircleFrame.Visible = CircleObj.Visible
		CircleFrame.ZIndex = CircleObj.ZIndex
		UICorner.CornerRadius = UDim.new(1, 0)
		CircleFrame.Size = UDim2.fromOffset(CircleObj.Radius, CircleObj.Radius)
		UIStroke.Thickness = CircleObj.Thickness
		UIStroke.Enabled = not CircleObj.Filled
		UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		CircleFrame.Parent, UICorner.Parent, UIStroke.Parent = DrawingUI, CircleFrame, CircleFrame
		return setmetatable(table.create(0), {
			__newindex = function(_, index, value)
				if typeof(CircleObj[index]) == "nil" then return end
				if index == "Radius" then
					local radius = value * 2
					CircleFrame.Size = UDim2.fromOffset(radius, radius)
				elseif index == "Position" then
					CircleFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Thickness" then
					value = math.clamp(value, .6, 0x7fffffff)
					UIStroke.Thickness = value
				elseif index == "Filled" then
					CircleFrame.BackgroundTransparency = (if value then ConvertTransparency(CircleObj.Transparency) else 1)
					UIStroke.Enabled = not value
				elseif index == "Visible" then
					CircleFrame.Visible = value
				elseif index == "ZIndex" then
					CircleFrame.ZIndex = value
				elseif index == "Transparency" then
					local transparency = ConvertTransparency(value)
					CircleFrame.BackgroundTransparency = (if CircleObj.Filled then transparency else 1)
					UIStroke.Transparency = transparency
				elseif index == "Color" then
					CircleFrame.BackgroundColor3 = value
					UIStroke.Color = value
				end
				CircleObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						CircleFrame:Destroy()
						CircleObj.Remove(self)
						return CircleObj:Remove()
					end
				end
				return CircleObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
	elseif Type == "Square" then
		local SquareObj = ({
			Size = Vector2.zero,
			Position = Vector2.zero,
			Thickness = .7,
			Filled = false
		} + BaseDrawingOBJ)
		local SquareFrame, UIStroke = Instance.new("Frame"), Instance.new("UIStroke")
		SquareFrame.Name = DrawingIDX
		SquareFrame.BorderSizePixel = 0
		SquareFrame.BackgroundTransparency = (if SquareObj.Filled then ConvertTransparency(SquareObj.Transparency) else 1)
		SquareFrame.ZIndex = SquareObj.ZIndex
		SquareFrame.BackgroundColor3 = SquareObj.Color
		SquareFrame.Visible = SquareObj.Visible
		UIStroke.Thickness = SquareObj.Thickness
		UIStroke.Enabled = not SquareObj.Filled
		UIStroke.LineJoinMode = Enum.LineJoinMode.Miter
		SquareFrame.Parent, UIStroke.Parent = DrawingUI, SquareFrame
		return setmetatable(table.create(0), {
			__newindex = function(_, index, value)
				if typeof(SquareObj[index]) == "nil" then return end
				if index == "Size" then
					SquareFrame.Size = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Position" then
					SquareFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Thickness" then
					value = math.clamp(value, 0.6, 0x7fffffff)
					UIStroke.Thickness = value
				elseif index == "Filled" then
					SquareFrame.BackgroundTransparency = (if value then ConvertTransparency(SquareObj.Transparency) else 1)
					UIStroke.Enabled = not value
				elseif index == "Visible" then
					SquareFrame.Visible = value
				elseif index == "ZIndex" then
					SquareFrame.ZIndex = value
				elseif index == "Transparency" then
					local transparency = ConvertTransparency(value)
					SquareFrame.BackgroundTransparency = (if SquareObj.Filled then transparency else 1)
					UIStroke.Transparency = transparency
				elseif index == "Color" then
					UIStroke.Color = value
					SquareFrame.BackgroundColor3 = value
				end
				SquareObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						SquareFrame:Destroy()
						SquareObj.Remove(self)
						return SquareObj:Remove()
					end
				end
				return SquareObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
	elseif Type == "Image" then
		local ImageObj = ({
			Data = "",
			DataURL = "rbxassetid://0",
			Size = Vector2.zero,
			Position = Vector2.zero
		} + BaseDrawingOBJ)
		local ImageFrame = Instance.new("ImageLabel")
		ImageFrame.Name = DrawingIDX
		ImageFrame.BorderSizePixel = 0
		ImageFrame.ScaleType = Enum.ScaleType.Stretch
		ImageFrame.BackgroundTransparency = 1
		ImageFrame.Visible = ImageObj.Visible
		ImageFrame.ZIndex = ImageObj.ZIndex
		ImageFrame.ImageTransparency = ConvertTransparency(ImageObj.Transparency)
		ImageFrame.ImageColor3 = ImageObj.Color
		ImageFrame.Parent = DrawingUI
		return setmetatable(table.create(0), {
			__newindex = function(_, index, value)
				if typeof(ImageObj[index]) == "nil" then return end
				if index == "Data" then
                    warn("[ Data ]: Not available")
				elseif index == "DataURL" then 
					ImageFrame.Image = value
				elseif index == "Size" then
					ImageFrame.Size = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Position" then
					ImageFrame.Position = UDim2.fromOffset(value.X, value.Y)
				elseif index == "Visible" then
					ImageFrame.Visible = value
				elseif index == "ZIndex" then
					ImageFrame.ZIndex = value
				elseif index == "Transparency" then
					ImageFrame.ImageTransparency = ConvertTransparency(value)
				elseif index == "Color" then
					ImageFrame.ImageColor3 = value
				end
				ImageObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						ImageFrame:Destroy()
						ImageObj.Remove(self)
						return ImageObj:Remove()
					end
				elseif index == "Data" then
					return warn("[ Data ]: Not available")
				end
				return ImageObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
	elseif Type == "Quad" then
		local QuadProperties = ({
			Thickness = 1,
			PointA = Vector2.new();
			PointB = Vector2.new();
			PointC = Vector2.new();
			PointD = Vector2.new();
			Filled = false;
		}  + BaseDrawingOBJ);
		local PointA = getgenv().Drawing.new("Line")
		local PointB = getgenv().Drawing.new("Line")
		local PointC = getgenv().Drawing.new("Line")
		local PointD = getgenv().Drawing.new("Line")
		return setmetatable({}, {
			__newindex = (function(self, Property, Value)
				if Property == "Thickness" then
					PointA.Thickness = Value
					PointB.Thickness = Value
					PointC.Thickness = Value
					PointD.Thickness = Value
				end
				if Property == "PointA" then
					PointA.From = Value
					PointB.To = Value
				end
				if Property == "PointB" then
					PointB.From = Value
					PointC.To = Value
				end
				if Property == "PointC" then
					PointC.From = Value
					PointD.To = Value
				end
				if Property == "PointD" then
					PointD.From = Value
					PointA.To = Value
				end
				if Property == "Visible" then 
					PointA.Visible = true
					PointB.Visible = true
					PointC.Visible = true
					PointD.Visible = true    
				end
				if Property == "Filled" then
					warn("[ Filled ]: Not available")
				end
				if Property == "Color" then
					PointA.Color = Value
					PointB.Color = Value
					PointC.Color = Value
					PointD.Color = Value
				end
				if (Property == "ZIndex") then
					PointA.ZIndex = Value
					PointB.ZIndex = Value
					PointC.ZIndex = Value
					PointD.ZIndex = Value
				end
			end),
			__index = (function(self, Property)
				if (string.lower(tostring(Property)) == "remove") then
					return (function()
						PointA:Remove();
						PointB:Remove();
						PointC:Remove();
						PointD:Remove();
					end)
				end
				return QuadProperties[Property]
			end)
		});
	elseif Type == "Triangle" then
		local TriangleObj = ({
			PointA = Vector2.zero,
			PointB = Vector2.zero,
			PointC = Vector2.zero,
			Thickness = 1,
			Filled = false
		} + BaseDrawingOBJ)
		local LinePoints = table.create(0)
		LinePoints.A = getgenv().Drawing.new("Line")
		LinePoints.B = getgenv().Drawing.new("Line")
		LinePoints.C = getgenv().Drawing.new("Line")
		return setmetatable(table.create(0), {
			__tostring = function() return "Drawing" end,
			__newindex = function(_, index, value)
				if typeof(TriangleObj[index]) == "nil" then return end
				if index == "PointA" then
					LinePoints.A.From = value
					LinePoints.B.To = value
				elseif index == "PointB" then
					LinePoints.B.From = value
					LinePoints.C.To = value
				elseif index == "PointC" then
					LinePoints.C.From = value
					LinePoints.A.To = value
				elseif (index == "Thickness" or index == "Visible" or index == "Color" or index == "ZIndex") then
					for _, LinePoint in LinePoints do
						LinePoint[index] = value
					end
				elseif index == "Filled" then
					warn("[ Filled ]: Not available")
				end
				TriangleObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						for _, LinePoint in LinePoints do
							LinePoint:Remove()
						end
						TriangleObj.Remove(self)
						return TriangleObj:Remove()
					end
				end
				return TriangleObj[index]
			end,
		})
	end
end)
getgenv().isrenderobj = newcclosure(function(obj)
    if not getmetatable(obj) then return false end
    if type(getmetatable(obj).__tostring) ~= "function" then return false end
    if getmetatable(obj).__tostring() ~= "Drawing" then return false end
    if type(obj.Visible) ~= "boolean" then return false end
    if type(obj.Remove) ~= "function" then return false end
    return true
end)
getgenv().cleardrawcache = newcclosure(function()
    for _, child in pairs(DrawingUI:GetChildren()) do
        child:Destroy()
    end
end)
getgenv().getrenderproperty = newcclosure(function(obj, property)
    if not pcall(function() isrenderobj(obj) end) then
        error("Invalid render object provided", 2)
    end
    if obj[property] == nil then
        error("Property '" .. tostring(property) .. "' does not exist on the object", 2)
    end
    return obj[property]
end)
getgenv().setrenderproperty = newcclosure(function(obj, property, value)
    if not pcall(function() isrenderobj(obj) end) then
        error("Invalid render object provided", 2)
    end
    if obj[property] == nil then
        error("Property '" .. tostring(property) .. "' does not exist on the object", 2)
    end
    pcall(function()
        obj[property] = value
    end)
end)
getgenv().makewriteable = newcclosure(function(taable)
    return setreadonly(taable, false)
end)
getgenv().iswriteable = newcclosure(function(tbl)
    return not table.isfrozen(tbl)
end)
getgenv().httppost = newcclosure(function(URL, body, contenttype) 
    return game:HttpPostAsync(URL, body, contenttype)
end)
getgenv().syn.protect_gui = newcclosure(function(gui)
    names[gui] = {name = gui.Name, parent = gui.Parent}
    protecteduis[gui] = gui
    gui.Name = crypt.random(64)
    gui.Parent = gethui()
end)
getgenv().syn.unprotect_gui = newcclosure(function(gui)
    if names[gui] then
        gui.Name = names[gui].name
        gui.Parent = names[gui].parent
    end
    protecteduis[gui] = nil
end)
getgenv().syn.secure_call = newcclosure(function(func)
    local suc, rec = pcall(func) 
	if not suc then 
		warn("[ Syn Secure Call ]: "..tostring(rec))
	end 
end)
getgenv().getprotecteduis = newcclosure(function()
    return protecteduis
end)

local testdebug = table.clone(debug)

testdebug.getconstant = getgenv().getconstant
testdebug.getconstants = getgenv().getconstants
testdebug.getinfo = getgenv().getinfo
testdebug.setconstant = getgenv().setconstant
testdebug.getproto = getgenv().getproto
testdebug.getprotos = getgenv().getprotos
testdebug.getstack = getgenv().getstack
testdebug.setstack = getgenv().setstack
testdebug.getupvalue = getgenv().getupvalue
testdebug.getupvalues = getgenv().getupvalues
testdebug.setupvalue = getgenv().setupvalue
testdebug.getregistry = getgenv().getregistry

debug = testdebug

getgenv().bit = {}

for i, v in next, bit32 do
bit[i] = v
end

bit.ror = bit.rrotate
bit.rol = bit.lrotate
bit.rrotate = nil
bit.lrotate = nil

bit.badd = function(a, b)
   return a + b
end

bit.bsub = function(a, b)
   return a - b
end

bit.bdiv = function(a, b)
   return a / b
end

bit.bmul = function(a, b)
   return a * b
end

bit.tobit = function(x)
  x = x % (2^32)
  if x >= 0x80000000 then x = x - (2^32) end
  return x
end

bit.tohex = function(x, n)
 n = n or 8
 local up
 if n <= 0 then
   if n == 0 then return '' end
   up = true
   n = - n
 end
 x = bit.band(x, 16^n-1)
 return ('%0'..n..(up and 'X' or 'x')):format(x)
end

bit.bswap = function(x)
 local a = bit.band(x, 0xff)
 x = bit.rshift(x, 8)
 local b = bit.band(x, 0xff)
 x = bit.rshift(x, 8)
 local c = bit.band(x, 0xff)
 x = bit.rshift(x, 8)
 local d = bit.band(x, 0xff)
 return bit.lshift(bit.lshift(bit.lshift(a, 8) + b, 8) + c, 8) + d
end

getgenv().setthreadidentity = newcclosure(function(identity: number): ()
    _setidentity(identity)
    task.wait()
end)

getgenv().setidentity = getgenv().setthreadidentity
getgenv().setthreadcontext = getgenv().setthreadidentity

getgenv().getinstances = newcclosure(function()
            local objs = {}
            for i,v in next, getreg() do
               if type(v)=='table' then
                  for o,b in next, v do
                      if typeof(b) == "Instance" then
                           table.insert(objs, b)
                      end
                  end
               end
            end
         return objs
 end)


do
    local CoreGui = game:GetService('CoreGui')
    local HttpService = game:GetService('HttpService')

    local comm_channels = CoreGui:FindFirstChild('comm_channels') or Instance.new('Folder', CoreGui)
    if comm_channels.Name ~= 'comm_channels' then
        comm_channels.Name = 'comm_channels'
    end
    getgenv().create_comm_channel = newcclosure(function() 
        local id = HttpService:GenerateGUID()
        local event = Instance.new('BindableEvent', comm_channels)
        event.Name = id
        return id, event
    end)

    getgenv().get_comm_channel = newcclosure(function(id) 
        assert(type(id) == 'string', 'string expected as argument #1')
        return comm_channels:FindFirstChild(id)
    end)
end

getgenv().getactors = newcclosure(function()
    local actors = {};
    for i, v in game:GetDescendants() do
        if v:IsA("Actor") then
            table.insert(actors, v);
        end
    end
    return actors;
end);

getgenv().getnilinstances = newcclosure(function()
    local objs = {}
	for i,v in next,getreg() do
		if type(v)=="table" then
			for o,b in next,v do
				if typeof(b) == "Instance" and b.Parent==nil then
					table.insert(objs, b)
				end
			end
		end
	end
	return objs
end)

getgenv().getscripthash = newcclosure(function(script)
    return script:GetHash()
end)

setreadonly(getgenv().debug,false)
getgenv().debug.traceback = getrenv().debug.traceback
getgenv().debug.profilebegin = getrenv().debug.profilebegin
getgenv().debug.profileend = getrenv().debug.profileend
getgenv().debug.getmetatable = getgenv().getrawmetatable
getgenv().debug.setmetatable = getgenv().setrawmetatable
getgenv().debug.info = getrenv().debug.info

getgenv().getrunningscripts = newcclosure(function()
    local t = table.create(0)

    for i,v in pairs(getreg()) do
        if typeof(v) == "thread" then
            local a = gettenv(v)

            if a["script"] then
                if not table.find(t,a.script) then
                    table.insert(t, a.script)
                end
            end
        end
    end

return t

end)

getgenv().getloadedmodules = newcclosure(function()
    local list = {}
    for i, v in getgc(false) do
        if typeof(v) == "function" then
            local success, env = pcall(getfenv, v)
            if success and typeof(env) == "table" and typeof(env["script"]) == "Instance" and env["script"]:IsA("ModuleScript") then
                if not table.find(list, env["script"]) then
                    table.insert(list, env["script"])
                end
            end
        end
    end
    return list
end)

getgenv().getsenv = newcclosure(function(script_instance)
   for i, v in pairs(getreg()) do
      if type(v) == "function" then
         if getfenv(v).script == script_instance then
             return getfenv(v)
             end
          end
     end
end)

getgenv().isnetworkowner = newcclosure(function(part: BasePart): boolean
    return part.ReceiveAge == 0 and not part.Anchored and part.Velocity.Magnitude > 0
end)

getgenv().firesignal = newcclosure(function(signal, ...)
    local connections = getconnections(signal)
    for _, connection in connections do
        connection.Function(...)
    end
end)

getgenv().setsimulationradius = newcclosure(function(newRadius)
    assert(newRadius, `arg #1 is missing`)
    assert(type(newRadius) == "number", `arg #1 must be type number`)

    local LocalPlayer = game:GetService("Players").LocalPlayer
    if LocalPlayer then
        LocalPlayer.SimulationRadius = newRadius
        LocalPlayer.MaximumSimulationRadius = newRadius
    end
end)

getgenv().getsimulationradius = newcclosure(function()
    assert(newRadius, `arg #1 is missing`)
    assert(type(newRadius) == "number", `arg #1 must be type number`)

    local LocalPlayer = game:GetService("Players").LocalPlayer
    if LocalPlayer then
        return LocalPlayer.SimulationRadius
    end
end)

getgenv().fireproximityprompt = newcclosure(function(proximityprompt, amount, skip)
    assert(
        typeof(proximityprompt) == "Instance" and proximityprompt:IsA("ProximityPrompt"),
        `arg #1 must be ProximityPrompt`
    )

    if amount ~= nil then
        assert(type(amount) == "number", `arg #2 must be type number`)
        if skip ~= nil then
            assert(type(skip) == "boolean", `arg #3 must be type boolean`)
        end
    end

    local oldHoldDuration = proximityprompt.HoldDuration
    local oldMaxDistance = proximityprompt.MaxActivationDistance

    proximityprompt.MaxActivationDistance = 9e9 -- client replicated only
    proximityprompt:InputHoldBegin()

    for i = 1, amount or 1 do -- or 1 cuz number can be nil
        if skip then
            proximityprompt.HoldDuration = 0
        else
            task.wait(proximityprompt.HoldDuration + 0.01) -- better than wait()
        end
    end

    proximityprompt:InputHoldEnd()
    proximityprompt.MaxActivationDistance = oldMaxDistance
    proximityprompt.HoldDuration = oldHoldDuration
end)

getgenv().http = {}
getgenv().http.request = request
setreadonly(http, true)

getgenv().http_request = request

getgenv().base64 = {}
getgenv().crypt = {}
getgenv().crypt.base64 = {}

getgenv().crypt.base64encode = getgenv().base64encode
getgenv().crypt.base64.encode = getgenv().base64encode
getgenv().crypt.base64_encode = getgenv().base64encode
getgenv().base64.encode = getgenv().base64encode
getgenv().base64_encode = getgenv().base64encode

getgenv().crypt.base64decode = getgenv().base64decode
getgenv().crypt.base64.decode = getgenv().base64decode
getgenv().crypt.base64_decode = getgenv().base64decode
getgenv().base64.decode = getgenv().base64decode
getgenv().base64_decode = getgenv().base64decode

getgenv().crypt.encrypt = getgenv().encrypt
getgenv().crypt.decrypt = getgenv().decrypt

getgenv().crypt.generatebytes = getgenv().generatebytes

getgenv().crypt.generatekey = getgenv().generatekey
getgenv().crypt.hash = getgenv().hash

setreadonly(getgenv().base64, true)
setreadonly(getgenv().crypt, true)

local _oldd = clonefunction(getscriptclosure_handler)

getgenv().getscriptclosure = newcclosure(function(scr) 
	local closure = _oldd(scr)

	if typeof(closure) == "function" then
		local scriptEnv = getfenv(closure)

		scriptEnv["script"] = scr

		return closure
	else
		return nil
	end
end)

getgenv().getscriptfunction = getgenv().getscriptclosure

local oldreq = clonefunction(getrenv().require)
getgenv().require = newcclosure(function(v)
    local oldlevel = getthreadcontext()
    local succ, res = pcall(oldreq, v)
    if not succ and res:find('RobloxScript') then
        succ = nil
        coroutine.resume(coroutine.create(newcclosure(function()
            setthreadcontext((oldlevel > 5 and 2) or 8)
            succ, res = pcall(oldreq, v)
        end)))
        repeat task.wait() until succ ~= nil
    end
    
    setthreadcontext(oldlevel)
    
    if succ then
        return res
    end
end)
getgenv().isreadable = isreadonly 
getgenv().isexecclosure = isexecutorclosure
getgenv().is_executor_closure = isexecclosure
getgenv().clonefunc = clonefunction
getgenv().get_scripts = getrunningscripts
getgenv().getmodules = getloadedmodules
getgenv().makereadonly = setreadonly
getgenv().make_readonly = getgenv().makereadonly
getgenv().is_l_closure = islclosure 
getgenv().randomstring = crypt.random
getgenv().syn.write_clipboard = setclipboard
getgenv().setrbxclipboard = setclipboard
getgenv().writeclipboard = setclipboard
getgenv().syn_backup = getgenv().syn
getgenv().syn.crypt = crypt
getgenv().syn.crypto = crypt
getgenv().syn.cache_replace = cache.replace 
getgenv().syn.cache_invalidate = cache.invalidate 
getgenv().syn.is_cached = cache.iscached 
getgenv().syn.set_thread_identity = setthreadidentity 
getgenv().syn.request = request 
getgenv().syn.get_thread_identity = getthreadidentity 
getgenv().syn.queue_on_teleport = queueonteleport 
getgenv().fluxus = {}
getgenv().fluxus.set_thread_identity = setthreadidentity 
getgenv().fluxus.queue_on_teleport = queueonteleport
getgenv().fluxus.request = request 
getgenv().string = string
getgenv().dumpbytecode = getscriptbytecode 
getgenv().loadfileasync = loadfile
getgenv().clearconsole = rconsoleclear 
getgenv().printconsole = rconsoleprint 
getgenv().getsynasset = getcustomasset 
getgenv().debug.getregistry = getreg 
getgenv().readfileasync = readfile 
getgenv().writefileasync = writefile
getgenv().appendfileasync = appendfile 
getgenv().saveplace = saveinstance 
getgenv().protect_gui = syn.protect_gui 
getgenv().unprotect_gui = syn.unprotect_gui 
getgenv().set_thread_identity = setthreadidentity 
getgenv().get_thread_identity = getthreadidentity 
getgenv().checkcallstack = checkcaller 
getgenv().syn.protectgui = getgenv().syn.protect_gui
getgenv().syn.unprotectgui = getgenv().syn.unprotect_gui
getgenv().getprotectedguis = getgenv().getprotecteduis
getgenv().debug.isvalidlevel = getgenv().debug.validlevel
getgenv().is_our_closure = isexecutorclosure 
getgenv().issynapsefunction = isexecutorclosure
getgenv().setrbxclipboard = setclipboard
getgenv().IS_SALAD_LOADED = true
